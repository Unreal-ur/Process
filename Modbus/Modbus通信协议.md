### **Modbus**通信协议

大致分为以下几种:

- Modbus-RTU
- Modbus-ASCII
- Modbus-TCP

Modbus是一种传输协议，位于OSI模型第七层，一个主设备（Master）可以询问多个从设备（Slave），从设备响应请求，但从设备不会主动发送数据。

------

#### **Modbus常用功能码**

| 代码 | 功能                                                         |
| ---- | ------------------------------------------------------------ |
| 0x01 | 读取从线圈的输出状态                                         |
| 0x02 | 读取从线圈的输入状态；如果从设备接收主设备的请求，则回复功能码02，并返回输入的各个状态 |
| 0x03 | 用于读取从设备保持寄存器值的内容（不支持广播模式）           |
| 0x04 | 用于读取从设备输入寄存器值的内容（不支持广播模式）           |
| 0x05 | 设置单个寄存器线圈的通断，在广播模式下所有从站设备同一地址的值将被统一修改 |
| 0x06 | 设置单个保持寄存器的值，在广播模式下所有从站设备同一地址的值将被统一修改 |
| 0x08 | 用于诊断主设备和从设备之间的通信故障，或者从设备的内部故障（不支持广播模式） |
| 0x0B | 获取从设备通信计数器的状态字和事件计数的值，可用来诊断通信是否丢帧（不支持广播模式） |
| 0x0C | 获取从设备状态字、事件计数、报文计数和事件字节字段           |
| 0x0F | 可同时设置多个寄存器线圈的通断，在广播模式下所有从站设备同一地址的值将被统一修改 |
| 0x10 | 用于一次性修改一个从站设备中多个连续的保持寄存器的值         |
| 0x11 | 用于读取从站设备ID、类型描述、当前状态以及其他信息（不支持广播模式） |



------

#### **线圈（coil）和寄存器（register）**

​		在modbus协议中之所以仍然称线圈和寄存器完全是由于历史原因，在PLC应用领域，一个线圈代表一个PLC输出点，也成为输出继电器，在现在的modbus设备中，他们都只是对于一块内存区域，一个线圈代表一位（bit），寄存器代表一个字（word）。在modbus中一个字表示两个字节。

| 数据类型       | 访问权限 | 大小        | 协议地址范围  | 常用称呼   | 类比解释                                         |
| :------------- | :------- | :---------- | :------------ | :--------- | :----------------------------------------------- |
| **线圈**       | 读/写    | 1位 (Bit)   | 00001 - 09999 | 离散输出   | **开关**：控制灯的开(1)与关(0)                   |
| **离散输入**   | 只读     | 1位 (Bit)   | 10001 - 19999 | 离散输入   | **按钮状态**：**只能读取**按钮是否被按下(1或0)   |
| **输入寄存器** | 只读     | 16位 (Word) | 30001 - 39999 | 输入寄存器 | **传感器读数**：**只能读取**的温度、压力等测量值 |
| **保持寄存器** | 读/写    | 16位 (Word) | 40001 - 49999 | 保持寄存器 | **系统参数**：可以读取和修改的温度设定值、速度等 |

#### **协议地址和内存地址**

这是最大的 confusion（混淆点）！

- **协议地址**：Modbus协议中定义的地址，即上表中的 `00001`, `10001`, `30001`, `40001`。**你在软件（如Modbus Poll, 你的代码）中使用的就是这个地址。**
- **内存/寄存器地址**：设备制造商在其编程手册中使用的地址，通常是从 **0** 开始的十六进制或十进制数。

**它们之间存在一个偏移量关系！**

| 数据类型       | 协议地址起点 | 内存地址起点 | **转换关系 (非常重要！)**     |
| :------------- | :----------- | :----------- | :---------------------------- |
| **线圈**       | 00001        | 0            | `协议地址 = 内存地址 + 1`     |
| **离散输入**   | 10001        | 0            | `协议地址 = 内存地址 + 10001` |
| **输入寄存器** | 30001        | 0            | `协议地址 = 内存地址 + 30001` |
| **保持寄存器** | 40001        | 0            | `协议地址 = 内存地址 + 40001` |

**举例：**
设备手册说：“目标温度参数”存储在**保持寄存器 0x0000**。
那么，你在Modbus Poll软件里应该访问的地址是：**40001** (即 0 + 40001)。
如果你看到手册写的是“寄存器地址 1”，那你应该访问 **40002**。

------

#### **Modbus RTU模式**

​	**Modbus RTU** 是 Modbus 协议的一种**传输模式**，它运行在串行通信之上（最常见的是 RS-485），可以理解为：**Modbus RTU = Modbus 应用层协议 + RTU 报文帧结构 + RS-485 物理层**。

一个完整的 RTU 报文帧结构如下：

![img](https://image.modbus.cn/wp-content/uploads/2024/04/20240429003355340.png)

| 组成部分     | 长度          | 描述                                                         | 示例 (十六进制)     |
| :----------- | :------------ | :----------------------------------------------------------- | :------------------ |
| **起始间隔** | ≥ 3.5字符时间 | **帧开始的标志**。不是实际发送的数据，而是一段**静默时间**（根据波特率计算）。 | (无实际数据)        |
| **从站地址** | 1 Byte        | 数据要发送到的从设备的地址（1 - 247）。地址 0 用于广播，所有从站都会接收但不应答。 | `01`                |
| **功能码**   | 1 Byte        | 指示从站要执行的操作（如读线圈、写寄存器）。                 | `03` (读保持寄存器) |
| **数据**     | N Bytes       | 请求或响应所携带的具体数据内容，长度和内容由功能码决定。     | `00 00 00 02`       |
| **CRC校验**  | 2 Bytes       | **循环冗余校验码**。由发送端计算并附加到报文末尾，接收端会重新计算并核对，用于检测传输过程中是否出现错误。 | `F7 89`             |
| **结束间隔** | ≥ 3.5字符时间 | **帧结束的标志**。同样是一段**静默时间**。                   |                     |

**帧的起始和结束不是通过特定的开始/结束字符，而是通过 3.5 个字符时间的静默区间来判定的。** 这是 RTU 模式与 ASCII 模式的主要区别之一。

------

#### **Modbus Ascll模式**

它的核心特点是使用**可打印的 ASCII 字符**来表示所有数据，这使得它**人类可读**，非常便于调试，但代价是通信效率较低。

可以把它理解为：**Modbus ASCII = Modbus 应用层协议 + ASCII 编码 + 特殊的帧头帧尾 + RS-232/485 物理层**。

一个完整的 ASCII 报文帧结构如下：

![img](https://image.modbus.cn/wp-content/uploads/2024/04/20240429003355176.png)

| 组成部分      | ASCII 字符   | 描述                                                         | 示例 (ASCII 字符)                        |
| :------------ | :----------- | :----------------------------------------------------------- | :--------------------------------------- |
| **起始符**    | `:` (冒号)   | **帧开始的标志**。固定为单个冒号字符 `:`。                   | `:`                                      |
| **地址域**    | 2个字符      | 从站地址，用**两个**十六进制 ASCII 字符表示。                | `'0'‘1’` 表示地址 1。                    |
| **功能码域**  | 2个字符      | 要执行的功能，用**两个**十六进制 ASCII 字符表示。            | `'0'‘3’` 表示功能码 03（读保持寄存器）。 |
| **数据域**    | N * 2 个字符 | 数据内容，每个字节的数据都用**两个**十六进制 ASCII 字符表示。 | `'0''0''0''0''0''0''0''2'`               |
| **LRC校验域** | 2个字符      | **纵向冗余校验码**。由发送端计算并附加，用**两个**十六进制 ASCII 字符表示。 | `'F''7'`                                 |
| **结束符**    | `CR` `LF`    | **帧结束的标志**。固定为回车符 `CR` (ASCII 13) 和换行符 `LF` (ASCII 10)。 |                                          |

**重要特点**：

- **可读性**：整个报文帧（除了起始和结束符）都是可打印的字符，例如 `0-9, A-F`，人类可以直接读懂。
- **效率低**：在 RTU 模式中，一个字节 `0x4B` 就直接发送了。但在 ASCII 模式中，同样的值需要拆成字符 `'4'` 和 `'B'`（其二进制值为 `0x34` 和 `0x42`）来发送，数据量翻倍，传输时间也更长。
- **帧界定简单**：通过明确的字符 `:` 和 `<CR><LF>` 来界定帧的开始和结束，对时序的要求不如 RTU 模式严格。

#### **LRC校验**

与 RTU 的 **CRC** 校验不同，ASCII 模式使用 **LRC** 校验。

- **计算方式**：将帧中所有字节（从地址域到数据域最后一个字节）的值相加，将结果取**二进制补码**（即先按位取反，再加1），最终取低8位。
- **目的**：与CRC一样，用于检测传输错误，但算法更简单，可靠性稍逊于CRC。

------

#### **Modbus TCP模式**

**Modbus TCP** 是 Modbus 协议的一种运行在 **TCP/IP** 网络之上的传输模式，它的核心思想是**将标准的 Modbus 帧嵌入到 TCP 数据包中**，从而可以通过以太网（Ethernet）进行通信，Modbus TCP不需要校验和计算，因为较低层的TCP/IP协议栈已经提供了校验和保护。

可以把它理解为：**Modbus TCP = Modbus 应用层协议 + TCP/IP 传输层 + 以太网物理层**。

一个 Modbus TCP 的**应用数据单元** 由 **MBAP头** + **Modbus PDU** 组成。

![Modbus 协议版本插图7](https://image.modbus.cn/wp-content/uploads/2024/04/20240429003356277.png?x-oss-process=image/format,webp)

**MBAP 头详解 (7字节)**

MBAP 头是 Modbus TCP 与 RTU 最根本的区别，它包含了在IP网络中路由数据所需的所有信息。

| 字段名           | 长度    | 描述                                                         | 示例/解释                                                    |
| :--------------- | :------ | :----------------------------------------------------------- | :----------------------------------------------------------- |
| **事务元标识符** | 2 Bytes | **由客户端（主站）生成**，用于将请求和响应配对。服务器（从站）在回应中必须原样返回。 | 主站发送请求时设置一个ID（如 `00 01`），从站回复时必须使用相同的ID（`00 01`），这样主站就能知道这个回复对应哪个请求。 |
| **协议标识符**   | 2 Bytes | 用于标识Modbus协议。**固定为 `00 00`**。                     | 表示这是Modbus协议。                                         |
| **长度**         | 2 Bytes | **表示后续字节的数量**，包括单元标识符和PDU（功能码+数据）。 | 例如，如果后面有5个字节（1字节单元ID + 1字节功能码 + 3字节数据），则长度字段为 `00 05`。 |
| **单元标识符**   | 1 Byte  | **用于标识远程从站设备**（类似于RTU中的从站地址）。          |                                                              |