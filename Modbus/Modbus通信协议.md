### **Modbus**通信协议

大致分为以下几种:

- Modbus-RTU
- Modbus-ASCII
- Modbus-TCP

Modbus是一种传输协议，位于OSI模型第七层，一个主设备（Master）可以询问多个从设备（Slave），从设备响应请求，但从设备不会主动发送数据。

------

#### **Modbus常用功能码**

| 代码 | 功能                                                         |
| ---- | ------------------------------------------------------------ |
| 0x01 | 读取从线圈的输出状态                                         |
| 0x02 | 读取从线圈的输入状态；如果从设备接收主设备的请求，则回复功能码02，并返回输入的各个状态 |
| 0x03 | 用于读取从设备保持寄存器值的内容（不支持广播模式）           |
| 0x04 | 用于读取从设备输入寄存器值的内容（不支持广播模式）           |
| 0x05 | 设置单个寄存器线圈的通断，在广播模式下所有从站设备同一地址的值将被统一修改 |
| 0x06 | 设置单个保持寄存器的值，在广播模式下所有从站设备同一地址的值将被统一修改 |
| 0x08 | 用于诊断主设备和从设备之间的通信故障，或者从设备的内部故障（不支持广播模式） |
| 0x0B | 获取从设备通信计数器的状态字和事件计数的值，可用来诊断通信是否丢帧（不支持广播模式） |
| 0x0C | 获取从设备状态字、事件计数、报文计数和事件字节字段           |
| 0x0F | 可同时设置多个寄存器线圈的通断，在广播模式下所有从站设备同一地址的值将被统一修改 |
| 0x10 | 用于一次性修改一个从站设备中多个连续的保持寄存器的值         |
| 0x11 | 用于读取从站设备ID、类型描述、当前状态以及其他信息（不支持广播模式） |



------

#### **线圈（coil）和寄存器（register）**

​		在modbus协议中之所以仍然称线圈和寄存器完全是由于历史原因，在PLC应用领域，一个线圈代表一个PLC输出点，也成为输出继电器，在现在的modbus设备中，他们都只是对于一块内存区域，一个线圈代表一位（bit），寄存器代表一个字（word）。在modbus中一个字表示两个字节。

| 数据类型       | 访问权限 | 大小        | 协议地址范围  | 常用称呼   | 类比解释                                         |
| :------------- | :------- | :---------- | :------------ | :--------- | :----------------------------------------------- |
| **线圈**       | 读/写    | 1位 (Bit)   | 00001 - 09999 | 离散输出   | **开关**：控制灯的开(1)与关(0)                   |
| **离散输入**   | 只读     | 1位 (Bit)   | 10001 - 19999 | 离散输入   | **按钮状态**：**只能读取**按钮是否被按下(1或0)   |
| **输入寄存器** | 只读     | 16位 (Word) | 30001 - 39999 | 输入寄存器 | **传感器读数**：**只能读取**的温度、压力等测量值 |
| **保持寄存器** | 读/写    | 16位 (Word) | 40001 - 49999 | 保持寄存器 | **系统参数**：可以读取和修改的温度设定值、速度等 |

#### **协议地址和内存地址**

这是最大的 confusion（混淆点）！

- **协议地址**：Modbus协议中定义的地址，即上表中的 `00001`, `10001`, `30001`, `40001`。**你在软件（如Modbus Poll, 你的代码）中使用的就是这个地址。**
- **内存/寄存器地址**：设备制造商在其编程手册中使用的地址，通常是从 **0** 开始的十六进制或十进制数。

**它们之间存在一个偏移量关系！**

| 数据类型       | 协议地址起点 | 内存地址起点 | **转换关系 (非常重要！)**     |
| :------------- | :----------- | :----------- | :---------------------------- |
| **线圈**       | 00001        | 0            | `协议地址 = 内存地址 + 1`     |
| **离散输入**   | 10001        | 0            | `协议地址 = 内存地址 + 10001` |
| **输入寄存器** | 30001        | 0            | `协议地址 = 内存地址 + 30001` |
| **保持寄存器** | 40001        | 0            | `协议地址 = 内存地址 + 40001` |

**举例：**
设备手册说：“目标温度参数”存储在**保持寄存器 0x0000**。
那么，你在Modbus Poll软件里应该访问的地址是：**40001** (即 0 + 40001)。
如果你看到手册写的是“寄存器地址 1”，那你应该访问 **40002**。

------

#### **Modbus RTU模式**

​	**Modbus RTU** 是 Modbus 协议的一种**传输模式**，它运行在串行通信之上（最常见的是 RS-485），可以理解为：**Modbus RTU = Modbus 应用层协议 + RTU 报文帧结构 + RS-485 物理层**。

一个完整的 RTU 报文帧结构如下：

![img](https://image.modbus.cn/wp-content/uploads/2024/04/20240429003355340.png)

| 组成部分     | 长度          | 描述                                                         | 示例 (十六进制)     |
| :----------- | :------------ | :----------------------------------------------------------- | :------------------ |
| **起始间隔** | ≥ 3.5字符时间 | **帧开始的标志**。不是实际发送的数据，而是一段**静默时间**（根据波特率计算）。 | (无实际数据)        |
| **从站地址** | 1 Byte        | 数据要发送到的从设备的地址（1 - 247）。地址 0 用于广播，所有从站都会接收但不应答。 | `01`                |
| **功能码**   | 1 Byte        | 指示从站要执行的操作（如读线圈、写寄存器）。                 | `03` (读保持寄存器) |
| **数据**     | N Bytes       | 请求或响应所携带的具体数据内容，长度和内容由功能码决定。     | `00 00 00 02`       |
| **CRC校验**  | 2 Bytes       | **循环冗余校验码**。由发送端计算并附加到报文末尾，接收端会重新计算并核对，用于检测传输过程中是否出现错误。 | `F7 89`             |
| **结束间隔** | ≥ 3.5字符时间 | **帧结束的标志**。同样是一段**静默时间**。                   |                     |

**帧的起始和结束不是通过特定的开始/结束字符，而是通过 3.5 个字符时间的静默区间来判定的。** 这是 RTU 模式与 ASCII 模式的主要区别之一。

一条 Modbus RTU 总线上最多能有 247 个从站，是因为 Modbus 协议规定了一个字节（8位）的地址字段，并且其中大部分地址被分配给了从站。

具体计算如下：

- 一个字节（8位二进制数）可以表示 **256** 个不同的值（范围是 0 到 255）。
- 在这 256 个地址中，**地址 0** 被保留用于**广播**。
- **地址 248 到 255** 被保留为**特殊用途**。
- 因此，可用的从站地址范围是 **1 到 247**。
- `247 = 255 - 8` （减去248-255这8个保留地址），而地址0是广播，不算作寻址用的从站地址。

所以，**可分配给从设备的唯一地址最多只有 247 个**。

##### **CRC校验**

CRC校验的核心思想是出发取余，简单比喻：你要发送一个数字 `123` 给朋友。你们约定好用 `12` 作为除数。

- 你计算 `123 ÷ 12 = 10 ... 3`。你把**原始数据 `123`** 和**余数 `3`** 一起发过去：`123, 3`。
- 你朋友收到后，他计算 `123 ÷ 12`，看看余数是不是你发过来的 `3`。如果是，就认为数字没抄错；如果不是，就知道中间肯定出错了。

CRC就是这个原理，只不过它是在二进制世界里用模2除法来操作。

```C/C++
unsigned short CRC16(unsigned char *puchMsg, unsigned short usDataLen)
{
    int i, j;
    unsigned short usRegCRC = 0xFFFF;
    
    for (i=0; i<usDataLen; i++)
    {
        usRegCRC ^= *puchMsg++;
        for (j=0; j<8; j++)
        {
            if (usRegCRC & 0x0001)
                usRegCRC = usRegCRC >> 1 ^ 0xA001;
            else
                usRegCRC >>= 1;
        }
    }
    
    return usRegCRC;
}
```



------

#### **Modbus Ascll模式**

它的核心特点是使用**可打印的 ASCII 字符**来表示所有数据，这使得它**人类可读**，非常便于调试，但代价是通信效率较低。

可以把它理解为：**Modbus ASCII = Modbus 应用层协议 + ASCII 编码 + 特殊的帧头帧尾 + RS-232/485 物理层**。

一个完整的 ASCII 报文帧结构如下：

![img](https://image.modbus.cn/wp-content/uploads/2024/04/20240429003355176.png)

| 组成部分      | ASCII 字符   | 描述                                                         | 示例 (ASCII 字符)                        |
| :------------ | :----------- | :----------------------------------------------------------- | :--------------------------------------- |
| **起始符**    | `:` (冒号)   | **帧开始的标志**。固定为单个冒号字符 `:`。                   | `:`                                      |
| **地址域**    | 2个字符      | 从站地址，用**两个**十六进制 ASCII 字符表示。                | `'0'‘1’` 表示地址 1。                    |
| **功能码域**  | 2个字符      | 要执行的功能，用**两个**十六进制 ASCII 字符表示。            | `'0'‘3’` 表示功能码 03（读保持寄存器）。 |
| **数据域**    | N * 2 个字符 | 数据内容，每个字节的数据都用**两个**十六进制 ASCII 字符表示。 | `'0''0''0''0''0''0''0''2'`               |
| **LRC校验域** | 2个字符      | **纵向冗余校验码**。由发送端计算并附加，用**两个**十六进制 ASCII 字符表示。 | `'F''7'`                                 |
| **结束符**    | `CR` `LF`    | **帧结束的标志**。固定为回车符 `CR` (ASCII 13) 和换行符 `LF` (ASCII 10)。 |                                          |

**重要特点**：

- **可读性**：整个报文帧（除了起始和结束符）都是可打印的字符，例如 `0-9, A-F`，人类可以直接读懂。
- **效率低**：在 RTU 模式中，一个字节 `0x4B` 就直接发送了。但在 ASCII 模式中，同样的值需要拆成字符 `'4'` 和 `'B'`（其二进制值为 `0x34` 和 `0x42`）来发送，数据量翻倍，传输时间也更长。
- **帧界定简单**：通过明确的字符 `:` 和 `<CR><LF>` 来界定帧的开始和结束，对时序的要求不如 RTU 模式严格。

##### **LRC校验**

与 RTU 的 **CRC** 校验不同，ASCII 模式使用 **LRC** 校验。

- **计算方式**：将帧中所有字节（从地址域到数据域最后一个字节）的值相加，将结果取**二进制补码**（即先按位取反，再加1），最终取低8位。
- **目的**：与CRC一样，用于检测传输错误，但算法更简单，可靠性稍逊于CRC。

```C/C++
unsigned char ucMBLRC(unsigned char *pucFrame, unsigned char usLen)
{
    unsigned char ucLRC = 0;  /* LRC字符初始化为0 */
    
    while (usLen--)           /* 处理消息中的所有字节 */
    {
        ucLRC += *pucFrame++; /* 累加每个字节的值 */
    }
    
    /* 返回二进制补码（取反后加1） */
    return (unsigned char)(-(char)ucLRC);
}
```



------

#### **Modbus TCP模式**

**Modbus TCP** 是 Modbus 协议的一种运行在 **TCP/IP** 网络之上的传输模式，它的核心思想是**将标准的 Modbus 帧嵌入到 TCP 数据包中**，从而可以通过以太网（Ethernet）进行通信，Modbus TCP不需要校验和计算，因为较低层的TCP/IP协议栈已经提供了校验和保护。

可以把它理解为：**Modbus TCP = Modbus 应用层协议 + TCP/IP 传输层 + 以太网物理层**。

一个 Modbus TCP 的**应用数据单元** 由 **MBAP头** + **Modbus PDU** 组成。

![Modbus 协议版本插图7](https://image.modbus.cn/wp-content/uploads/2024/04/20240429003356277.png?x-oss-process=image/format,webp)

**MBAP 头详解 (7字节)**

MBAP 头是 Modbus TCP 与 RTU 最根本的区别，它包含了在IP网络中路由数据所需的所有信息。

| 字段名           | 长度    | 描述                                                         | 示例/解释                                                    |
| :--------------- | :------ | :----------------------------------------------------------- | :----------------------------------------------------------- |
| **事务元标识符** | 2 Bytes | **由客户端（主站）生成**，用于将请求和响应配对。服务器（从站）在回应中必须原样返回。 | 主站发送请求时设置一个ID（如 `00 01`），从站回复时必须使用相同的ID（`00 01`），这样主站就能知道这个回复对应哪个请求。 |
| **协议标识符**   | 2 Bytes | 用于标识Modbus协议。**固定为 `00 00`**。                     | 表示这是Modbus协议。                                         |
| **长度**         | 2 Bytes | **表示后续字节的数量**，包括单元标识符和PDU（功能码+数据）。 | 例如，如果后面有5个字节（1字节单元ID + 1字节功能码 + 3字节数据），则长度字段为 `00 05`。 |
| **单元标识符**   | 1 Byte  | **用于标识远程从站设备**（类似于RTU中的从站地址）。          |                                                              |

------

#### **Modbus工作模式**

最核心、最根本的工作方式是：**主从模式**（客户端/服务器模式）。

下图是典型的**modbus主从模式**下的连接示意图，由一个客户端和多个服务器组成。

![Modbus 工作模式插图1](https://image.modbus.cn/wp-content/uploads/2024/04/20240429003306547.png?x-oss-process=image/format,webp)

在一条总线上同一时间内只能有一个客户端进行活动，总线上可以有其他的备用客户端，客户端会向总线上发送消息帧，包括从站地址、功能码和数据内容，监听到消息帧的对应服务器就会进行回应请求，而在全部时间段内，服务器永远不会主动向客户端和其他服务器发起通讯操作。

**一个生动的比喻：课堂提问**

- **主设备** = **老师**
- **从设备** = **学生**
- **总线** = **教室**
- **老师（主设备）** 点名叫：“**小明（从站地址1）**，请告诉我黑板上第三题（功能码：读寄存器，地址：30003）的答案。”
- **小明（从设备1）** 听到自己的名字后，回答道：“答案是42（响应数据）。”
- 老师不会同时叫两个学生，学生也不会主动抢答。整个课堂秩序井然。

------

#### **modbus异常响应**

当客户端发送一个请求帧后，它期望收到一个正常的响应帧。但是，如果服务器在处理请求时遇到了错误，它**不会返回正常响应**，而是会返回一个**异常响应帧**。

异常响应的核心机制是：

1. **修改功能码**：将正常响应中的功能码的最高位（Bit 7）**置 1**，相当于**原功能码 + 0x80**。
2. **添加异常码**：在功能码之后，增加一个字节的**异常码**，用于明确指示错误的具体类型。

**示例：**

- **主站请求**：读取保持寄存器（功能码 `0x03`）
  - 帧：`[地址] [03] [起始地址Hi] [起始地址Lo] [数量Hi] [数量Lo] [CRC]`
- **正常响应**：成功读取
  - 帧：`[地址] [03] [字节数] [数据1] [数据2] ... [CRC]`
- **异常响应**：请求失败（例如，寄存器地址无效）
  - 帧：`[地址] [83] [异常码] [CRC]` ← **注意功能码变成了 `0x83`**